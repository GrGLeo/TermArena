# Projectile Mechanism

## Goal

The primary goal of the projectile mechanism is to introduce dodgeable spells and attacks into the game. Previously, attacks dealt damage instantly, making it impossible for players to react or for abilities to have travel time. This new system transforms projectiles from mere visual effects into core gameplay entities that travel across the game board, allowing for more tactical gameplay, skillshots, and reactive dodging.

## Core Components

The projectile mechanism is primarily implemented in the `game` crate, specifically within the `game/src/game/entities/projectile.rs` and `game/src/game/projectile_manager.rs` files.

### `Projectile` Struct (`game/src/game/entities/projectile.rs`)

This struct represents an individual projectile in the game. Key fields include:
- `id`: Unique identifier for the projectile.
- `owner_id`: ID of the entity that fired the projectile (e.g., Tower, Champion).
- `path`: A pre-calculated sequence of cells the projectile will travel through. For straight-line projectiles, this is generated using Bresenham's Line Algorithm. For homing projectiles, the path is dynamically updated.
- `path_index`: Current position within the `path` vector.
- `speed`: How many game ticks it takes for the projectile to move one cell.
- `tick_counter`: Internal counter to track movement progress against `speed`.
- `payload`: The `GameplayEffect` (e.g., Damage, Stun) that the projectile will apply upon collision.
- `visual_cell_type`: The visual representation of the projectile on the game board.

The `Projectile` struct implements the `AnimationTrait`, allowing it to be integrated seamlessly into the game's existing animation system. The `update()` method handles its movement along its path, and `is_finished()` determines when it should be removed from the game.

### `ProjectileManager` (`game/src/game/projectile_manager.rs`)

This manager orchestrates all active projectiles in the game. Its main responsibilities include:
- **`create_skillshot_projectile(...)`**: Creates a new projectile with a pre-defined straight path.
- **`create_homing_projectile(...)`**: Creates a new projectile that tracks a specific target.
- **`update_and_check_collisions(...)`**: This is the central method called each game tick. It:
    1. Iterates through all active projectiles.
    2. Updates each projectile's position based on its `speed` and `path`.
    3. Performs collision detection: Checks if a projectile's current cell overlaps with any target entity (Champion, Minion, Tower) from the opposing team.
    4. If a collision occurs, applies the `projectile.payload` (e.g., damage) to the target and marks the projectile for removal.
    5. Collects animations and pending damages to be processed by the `GameManager`.
    6. Removes projectiles that have either hit a target or reached the end of their path.

## Interaction with the Game Loop (`GameManager::game_tick()`)

The projectile mechanism is tightly integrated into the main game loop, managed by the `GameManager` in `game/src/game/mod.rs`.

1.  **Projectile Creation (Tower Turn)**:
    - Within the `GameManager::tower_turn()` method, when a tower attacks an enemy, instead of directly applying damage, it now calls `self.projectile_manager.create_homing_projectile(...)`. This spawns a new `Projectile` entity that will travel towards the target.

2.  **Projectile Update and Collision Detection**:
    - In the `GameManager::game_tick()` function, after processing player inputs and minion movements, but *before* applying general damages, `self.projectile_manager.update_and_check_collisions(...)` is called. This is a crucial step where all active projectiles move, and any collisions are detected.
    - The `update_and_check_collisions` method returns:
        - `animations_to_keep`: Projectiles that are still active and need to be rendered.
        - `pending_damages`: A list of `(Target, u16)` tuples for damage that needs to be applied to entities.
        - `animation_commands_executable`: Specific `AnimationCommand`s (like `Draw` or `Clear`) generated by the projectiles for rendering.

3.  **Damage Application**:
    - The `pending_damages` returned by the `ProjectileManager` are then merged with other pending damages (e.g., from minion attacks) and applied to the respective entities (Towers, Minions, Champions, Bases).

4.  **Rendering**:
    - The `animation_commands_executable` from the `ProjectileManager` are added to the overall list of animation commands. These commands are then processed to update the game board's visual state, ensuring that projectile movement is correctly rendered to the client. The `GameManager` also handles clearing the previous frame's animation for all active animations, including projectiles, before processing their next frame.

This integration ensures that projectiles are dynamic, interactive elements within the game, allowing for a richer and more strategic gameplay experience.